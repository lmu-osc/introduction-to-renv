---
title: "Reproducibility"
fig-cap-location: bottom
bibliography: references.bib
---

# What is Reproducibility?

## A Brief Definition

> I propose to consider the question "What is reproducibility?" As reproducibility is such a central concept in science, one would think that it would be clearly defined. However, this is not the case. Reproducibility is an elusive concept. It has no single commonly agreed upon definition. Rather, it has many different, and each of these captures central, but different properties of it...
>
> -- <cite>Odd Erik Gundersen</cite> [-@erikgundersen2021]

Gundersen explores many definitions put forward for "reproducibility", but, for the purposes of this tutorial, his exploration of reproducibility is best summarized as "the ability of independent investigators to draw the same conclusions from an experiment by following the documentation shared by the original investigators" [@erikgundersen2021]. 

In principle, this sounds simple enough--provide others with enough information, and they should be able to reproduce your work! Achieving this in practice is, of course, a vastly complex endeavor that requires careful planning and execution. Above all, opinions on what constitutes sufficient "documentation" or how much documentation is necessary to achieve reproducibility can vary widely.

One might assume that academic publications provide all of the information required for an independent researcher to reproduce a publication; the requisite background on the topic, the data cleaning choices, and the exact statistical methods employed to arrive at a conclusion are theoretically included in a paper.[^1] In practice, a written publication generally cannot capture all of the nuances of data cleaning, exploration, and analysis employed by the original researchers. As a result, reproducing an analysis result only from a written description is, at best, incredibly time-consuming, and, at worst, an impossible endeavor.

[^1]: Assuming, of course, that the data for the analysis can also be accessed either because it is publicly available or by way of contacting the original researcher.

To address the shortcomings of written descriptions, **researchers must also strive to publish their code, data, and ideally both code and data together such that the *complete* documentation of the project is available to others.** 

## Reproducible Code

Why should we concern ourselves with making reproducible code specifically? From a scientific perspective, reproducible code is essential in allowing other researchers to verify findings, to build upon existing work, and to ensure that the scientific process is transparent and trustworthy. From a practical perspective, reproducible code can save time and effort in the long run by making it easier to revisit and understand one's own work, to make debugging and troubleshooting easier, and to collaborate with others.

In the context of this tutorial, we will focus on the practical aspects of making code reproducible. This mainly means taking steps to ensure that the code we write can be run on other machines, by other people, and in the future. In other words, we want to make sure that our code is **portable** and **future-proof** by ensuring the software originally used in creating our code is the same software used by others. Let's look at this in more detail.


# The \~Machines\~

## Your Computer

Getting code to work on your own machine is *usually* not too difficult. You can install the software you need, set up your environment, and run your code. 

What about all of the other machines where someone might want to use or contribute to your project though?


```{r, fig.cap="Traditionally, this has been sufficient for generating all of the analyses and figures needed to author manuscripts.", out.width="85%", echo=FALSE}
knitr::include_graphics("assets/img/works_on_my_machine.jpg")
```



## Someone Else's Computer

When you share your code with others, however, you are asking them to run *your* code on *their* machine, and it is unlikely that their machine is set up exactly like yours. They might not have the same software installed, or they might have different versions of the software you used. A non-exhaustive list of examples where there might be software discrepancies are detailed below.


### Examples of Machine & Software Differences

::: panel-tabset
## Operating systems

![](assets/img/mac_linux_windows.jpg)

It's already well-known that different operating systems can have different software requirements. For example, some software might only be available on Windows, while others might only be available on MacOS or Linux.

However, it is also important to consider that different versions of the same operating system can have different software requirements. For example, some software might only be compatible with Windows 10 and not Windows 11.


## Programming languages

![](assets/img/r_python_julia.jpg)

-   (e.g. R, Python, MATLAB, Julia, JavaScript)
-   Versions of programming languages (e.g. Python 2 and 3, R 3.5.3 and 4.3.3)[^2]

## Software Add-ons

![](assets/img/r_packages.png)

-   Add-on packages/libraries for a programming language
-   Versions of packages/libraries
:::


The point of this is to demonstrate how many degrees of freedom can exist in the software environment of a project. If you have ever tried to run someone else's code and it didn't work, it was likely due to one of these reasons.

Moreover, it's not possible to manage all of these differences manually. For example, you can't just tell someone to install Python v3.8.2, R v4.0.3, and a specific version of a package. This is not only impractical but also not a good use of time.


[^2]: Not so fun-fact: some "newer" versions of MacOS come with Python v2 installed because the OS has some dependencies on this version despite v3 being released in 2008; Python v3 is not entirely backwards compatible with v2.

**Do you see some themes here?**

::: callout-important
## Expect No One to Already Have the Required Software

-   Don't expect others to already have the software you rely on
-   Even if others have the software, don't expect them to have the **same version**
:::

## All of the Machines

So this brings us to our core question: how do we set up a project to work on everybody's machines?[^3] **By managing our software dependencies**, described in the next chapter.

[^3]: Within reason; many software and hardware configurations just simply were not meant to be, but most modern programming languages are cross-compatible across recent, major operating systems without issue.

<!-- footnotes -->
