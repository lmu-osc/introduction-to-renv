---
title: "Software Dependencies"
---


## Dependencies Overview

The general concept of software dependencies is relatively straightforward: "dependencies" are other softwares/programs that the software you're using or developing *depends* on to function. For example, if you are developing an R package, you will need R installed on your machine, or if you download an R package that uses functions from the `dplyr` package, `dplyr` is a library dependency that must be downloaded too.

There are many layers of dependencies that can exist in a project, and these dependencies can be difficult to manage. Extending the previous example, one must keep in mind that `dplyr` itself has dependencies, such as `tibble`, `rlang`, and `vctrs`, which must also be downloaded. And `tibble`, `rlang`, and `vctrs` have dependencies too, and so on. This process works recursively until all unique packages are identified, and a project that appears to only use e.g. 5-10 libraries can ultimately require a few dozen or hundred packages. This is not an R-specific problem, bur rather a common issue in software development known as "dependency hell."[^left-pad] 

[^left-pad]: If you have enough time, read about how the [left-pad incident](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code) broke the internet as an example of how dependencies can go wrong.

If you're ever curious about the dependencies of a package, there are a variety of ways you can find this information via the package's documentation:

* Reading the `DESCRIPTION` file of an R package, which can be accessed in a variety of ways
  - `utils::packageDescription()` to print the complete `DESCRIPTION` file of a package to the console
  - `tools::package_dependencies()` for just a list of dependencies from the `DESCRIPTION` file
  - Looking at the `DESCRIPTION` file online on the package's CRAN or GitHub page
* `pak::pkg_deps_tree()` for a visual representation of the direct dependencies **and** the recursive dependencies


## Intro to Management Practices

Given the potential complexity of software dependencies, it is important to manage these dependencies in a way that is both efficient and reproducible. This is especially important when sharing code with others or when working on a project over a long period of time so that you can easily recreate the environment in which the code was originally run.

You might already have a system in place for managing your dependencies, such as writing a document outlining installation procedures or you maintain a list of project packages, you might already use an automated package manager, or you might not have a system at all. Regardless of what you currently use, the manual and automated approaches are discussed below, and we clarify why you should use an automated approach for managing dependencies going forward.


### Manual management

As noted, the dependencies for your project can be managed manually with e.g. a written list of the softwares and versions used. The main pros to this approach is that little technical knowledge is needed to create a simple Word or text file with this information, and such information can likewise be shared easily. However, the cons are that this approach is inexact, error-prone, still requires another user to manually download each package/library by hand, and the recursive dependencies are unlikely to be logged. This approach is not recommended for any serious project, especially if you are working with others or if you are working on a project over a long period of time.


### Automated Management

Automated management of dependencies is the recommended approach for managing dependencies. This approach involves using a package manager to automatically install the necessary software dependencies for a project. The main pros to this approach are that it is more accurate, less error-prone, and can be easily shared with others. The cons are that it requires some technical knowledge to set up and can be more difficult to troubleshoot if something goes wrong. 

There are many package managers available for different programming languages, and the choice of package manager can depend on the programming language you are using, the complexity of your project, and your personal preferences. Some common package managers for R and Python are listed below:

::: panel-tabset

## R

The major current and historical options for managing R dependencies are:

1. {renv} is arguably the most important package for managing R dependencies, is maintained by Posit, and is our recommendation
2. {groundhogr} is a package that is similar to {renv}, and developed by independent, open-source contributors
2. {packrat} is a deprecated package that is no longer recommended for new projects

## Python

The pip, pipenv, and poetry libraries can, generally speaking, be used for library management and for declaring necessary Python versions in the respective `requirements.txt`, `Pipfile`, and `pyproject.toml` files. However, one would usually use this in conjunction with software like Anaconda or Miniconda to manage Python versions and environments.

:::


The next chapter delves into some necessary technical definitions in the R ecosystem. The chapters mentions some of the benefits of package managers, but the following chapter will really dive in to the details of package management in R while providing a discussion of the 3 major package managers for R.

