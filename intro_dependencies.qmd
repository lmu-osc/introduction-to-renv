---
title: "Software Dependencies"
---


## Dependencies Overview

The general concept of software dependencies is relatively straightforward: "dependencies" are other softwares/programs that the software you're using or developing *depends* on to function. For example, if you are developing an R package, you will need R installed on your machine, or if you download an R package that uses functions from the `dplyr` package, `dplyr` is a library dependency that must be downloaded too.

There are many layers of dependencies that can exist in a project, and these dependencies can be difficult to manage. Extending the previous example, one must keep in mind that `dplyr` itself has dependencies, such as `tibble`, `rlang`, and `vctrs`, which must also be downloaded. And `tibble`, `rlang`, and `vctrs` have dependencies too, and so on. This process works recursively until all unique packages are identified, and a project that appears to only use e.g. 5-10 libraries can ultimately require a few dozen or hundred packages. This is not an R-specific problem, bur rather a common issue in software development known as "dependency hell."[^left-pad] 

[^left-pad]: If you have enough time, read about how the [left-pad incident](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code) broke the internet as an example of how dependencies can go wrong.

If you're ever curious about the dependencies of a package, there are a variety of ways you can find this information via the package's documentation:

* `utils::packageDescription()` for the complete `DESCRIPTION` file of a package
* `tools::package_dependencies()` for just a list of dependencies from the `DESCRIPTION` file
*  Looking at the `DESCRIPTION` file and other contents of the package's GitHub page
* `pak::pkg_deps_tree()` for a visual representation of the direct dependencies **and** the recursive dependencies


## Intro to Management Practices

Given the potential complexity of software dependencies, it is important to manage these dependencies in a way that is both efficient and reproducible. This is especially important when sharing code with others or when working on a project over a long period of time so that you can easily recreate the environment in which the code was originally run.

You might already have a system in place for managing your dependencies, such as writing a document outlining installation procedures or you maintain a list of project packages, you might already use an automated package manager, or you might not have a system at all. Regardless of what you currently use, the manual and automated approaches are discussed below, and we clarify why you should use an automated approach for managing dependencies going forward.


### Manual management

As noted, the dependencies for your project can be managed manually with e.g. a written list of the softwares and versions used. The main pros to this approach is that little technical knowledge is needed to create a simple Word or text file with this information, and such information can likewise be shared easily. However, the cons are that this approach is inexact, error-prone, still requires another user to manually download each package/library by hand, and the recursive dependencies are unlikely to be logged. This approach is not recommended for any serious project, especially if you are working with others or if you are working on a project over a long period of time.


### Automated Management

-   Python: `requirements.txt`, `Pipfile`, and `pyproject.toml` for pip, pipenv, and poetry respectively can, generally speaking, be used for library management and for declaring necessary Python versions.
    -   this tutorial focuses on R and {renv} so no further comparison of these will be provided here
-   R: {renv}, {packrat}, and {groundhogr} are the major options in the R ecosystem
